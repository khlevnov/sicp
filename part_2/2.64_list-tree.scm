(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
    (list entry left right))

(define (list->tree elements)
    (car (partial-tree elements (length elements))))

(define (partial-tree elts n)
    (if (= n 0)
        (cons '() elts) ; for leaves, that equals nil
        (let ((left-size (quotient (- n 1) 2))) ; size of left subtree
            (let ((left-result (partial-tree elts left-size)))
                (let ((left-tree (car left-result)) ; left subtree
                      (non-left-elts (cdr left-result)) ; rest elements of list
                      (right-size (- n (+ left-size 1)))) ; size of right subtree
                     (let ((this-entry (car non-left-elts)) ; root of tree
                           (right-result (partial-tree (cdr non-left-elts) right-size)))
                          (let ((right-tree (car right-result))
                                (remaining-elts (cdr right-result)))
                               (cons (make-tree this-entry left-tree right-tree)
                                     remaining-elts))))))))

; // для множества (1 3 5 7 9 11)
; // вызывается с размером 6
; // берется размер левой ветки, это 2
; // рекурсивно вызывается для левой половины множества с размером 2
; // берется размер левой ветки, это 0
; // рекурсивно вызывается для левой половины множества с размером 0
; // в левую ветку возвращается '(), в рест все остальное (1 3 5 7 9 11)
; // берется размер правой ветки, это 1
; // выбирается родитель, это 1
; // рекурсивно вызывается для всех оставшихся элементов кроме первого (3 5 7 9 11) с размером 1
; // берется размер левой ветки, это 0
; // рекурсивно вызывается для левой половины множества с размером 0
; // в левую ветку возвращается '(), в рест все остальное (3 5 7 9 11)
; // берется размер правой ветки, это 0
; // выбирается родитель, это 3
; // рекурсивно вызывается для всех оставшихся элементов, кроме первого (5 7 9 11) с размером 0
; // в правую ветку возвращается '(), в рест все остальное (5 7 9 11)
; // возвращается пара, в голове которой (3 nil nil), в хвосте (5 7 9 11)
; // в правой ветке (3 nil nil), в рест (5 7 9 11)
; // возвращается пара, в голове которой (1 nil (3 nil nil)), в хвосте (5 7 9 11)
; // в левой ветке (1 nil (3 nil nil)), в нон лефт (5 7 9 11)
; // берется размер правой ветки, это 3
; // выбирается родитель, это 5
; // рекурсивно вызывается для всех оставшихся элементов кроме первого (7 9 11) с размером 3
; // берется размер левой ветки, это 1
; // рекурсивно вызывается для левой ветки (7 9 11) с размером 1
; // берется размер левой ветки, это 0
; // рекурсивно вызывается для левой ветки (7 9 11) с размером 0
; // в левую ветку возвращается '(), в рест все остальное (7 9 11)
; // берется размер правой ветки, это 0
; // выбирается родитель, это 7
; // рекурсивно вызывается для всех оставшихся элементов, кроме первого (9 11) с размером 0
; // в правую ветку возвращается '(), в рест все остальное (9 11)
; // возвращается пара, в голове которой (7 nil nil), в хвосте (9 11)
; // в левой ветке (7 nil nil), в нонлефт (9 11)
; // берется размер правой ветки, это 1
; // выбирается родитель, это 9
; // рекурсивно вызывается для всех элементов, кроме первого (11) с размером 1
; // берется размер левой ветки, это 0
; // рекурсивно вызывается для левой ветки (11) с размером 0
; // в левую ветку возвращается '(), в рест (11)
; // берется размер правой ветки, это 0
; // выбирается родитель, это 11
; // рекурсивно вызывается для всех элементов, кроме первого () с размером 0
; // в правую ветку возвращается '(), в рест ()
; // возвращается пара, в голове которой (11 nil nil), в хвосте ()
; // в правой ветке (11 nil nil), в рест ()
; // возвращается пара, в голове которой (9 (7 nil nil) (11 nil nil)), в хвосте ()
; // в правой ветке (9 (7 nil nil) (11 nil nil)), в рест ()
; // возвращается пара (5 (1 nil (3 nil nil)) (9 (7 nil nil) (11 nil nil))), в хвосте ()
; берется голова списка и возвращается как сбалансированное дерево

; Центральный элемент списка выбирается в качестве родителя, а левая часть рекурсивно строится в виде сбалансированного дерева, оставляя правый список в хвосте до лучших времен
; Порядок роста как O(n)
